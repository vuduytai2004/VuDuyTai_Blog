---
title: "`any` Được coi là có hại, ngoại trừ những trường hợp này"
description: "Khám phá khi nào là thích hợp để sử dụng kiểu `any` của Typescript bất chấp những rủi ro của nó. Tìm hiểu về các trường hợp hợp pháp mà `any` là cần thiết"
image: "/images/blog/any-considered.webp"
date: "2024-05-30"
author: "devbertskie"
---

`any` là một kiểu cực kỳ mạnh mẽ trong TypeScript. Nó cho phép bạn xử lý một giá trị như thể bạn đang ở trong JavaScript, không phải TypeScript. Điều này có nghĩa là nó vô hiệu hóa tất cả các tính năng của TypeScript - kiểm tra kiểu, tự động hoàn thành và an toàn.

```ts
const myFunction = (input: any) => {
  input.someMethod();
};

myFunction("abc"); // Điều này sẽ thất bại khi chạy!
```

Sử dụng `any` được coi là có hại bởi hầu hết cộng đồng. Có các [quy tắc ESLint](https://typescript-eslint.io/rules/no-explicit-any/) để ngăn chặn việc sử dụng nó. Điều này có thể khiến các nhà phát triển hoàn toàn không sử dụng `any`.

Tuy nhiên, có một vài trường hợp nâng cao mà `any` luôn là lựa chọn đúng đắn. Dưới đây là một số trong số chúng:

## Các ràng buộc đối số kiểu (Type Argument Constraints)

Hãy tưởng tượng chúng ta muốn triển khai tiện ích `ReturnType` trong TypeScript. Tiện ích này nhận vào một kiểu hàm và trả về kiểu của giá trị trả về của nó.

Chúng ta cần tạo một [generic type](https://www.totaltypescript.com/no-such-thing-as-a-generic#generic-types) nhận một kiểu hàm làm đối số kiểu. Nếu chúng ta tự hạn chế không sử dụng `any`, chúng ta có thể sử dụng `unknown`:

```ts
type ReturnType<T extends (...args: unknown[]) => unknown> =
  // Không quan trọng cho lời giải thích của chúng ta:
  T extends (...args: unknown[]) => infer R ? R : never;
```

Không quan trọng phải hiểu -tất cả- mã này, chỉ cần hiểu ràng buộc - `T extends (...args: unknown[]) => unknown`. Những gì chúng ta đang nói ở đây là chỉ các hàm chấp nhận một mảng đối số `unknown[]` và trả về `unknown` mới được phép.

Nó dường như hoạt động tốt cho các hàm không có đối số:

```ts
const myFunction = () => {
  console.log("Hey!");
};

type Result = ReturnType<typeof myFunction>;
```

Nhưng nó ngừng hoạt động ngay khi chúng ta thêm một đối số:

```ts
const myFunction = (input: string) => {
  console.log("Hey!");
};

type Result = ReturnType<typeof myFunction>;
```

Thực tế, nó chỉ hoạt động nếu chúng ta thay đổi tham số của hàm thành `input: unknown`:

```ts
const myFunction = (input: unknown) => {
  console.log("Hey!");
};

type Result = ReturnType<typeof myFunction>;
```

Vì vậy, vô tình, chúng ta đã tạo ra một `ReturnType` chỉ hoạt động trên các hàm chấp nhận `unknown` làm đối số. Đây không phải là điều chúng ta muốn. Chúng ta muốn nó hoạt động trên bất kỳ hàm nào.

Giải pháp là sử dụng `any[]` làm ràng buộc đối số kiểu:

```ts
type ReturnType<T extends (...args: any[]) => any> = T extends (
  ...args: any[]
) => infer R
  ? R
  : never;

const myFunction = (input: string) => {
  console.log("Hey!");
};

type Result = ReturnType<typeof myFunction>;
```

Bây giờ nó hoạt động như mong đợi. Chúng ta đang tuyên bố rằng chúng ta không quan tâm hàm chấp nhận kiểu gì - nó có thể là bất cứ thứ gì.

Lý do điều này an toàn là vì chúng ta đang cố tình khai báo một kiểu rộng. Chúng ta đang nói "Tôi không quan tâm hàm chấp nhận gì, miễn là nó là một hàm". Đây là một cách sử dụng an toàn của `any`.

## Trả về Kiểu có điều kiện từ Hàm Generic

Ở một số nơi, khả năng thu hẹp (narrowing) của TypeScript không tốt như chúng ta mong muốn. Giả sử chúng ta muốn tạo một hàm trả về các kiểu khác nhau dựa trên một điều kiện:

```ts
const youSayGoodbyeISayHello = (input: "hello" | "goodbye") => {
  if (input === "goodbye") {
    return "hello";
  } else {
    return "goodbye";
  }
};

const result = youSayGoodbyeISayHello("hello");
```

Hàm này không thực sự làm những gì chúng ta muốn. Chúng ta muốn nó trả về kiểu `"goodbye"` khi chúng ta truyền vào `"hello"`. Nhưng hiện tại, `result` được định kiểu là `"hello" | "goodbye"`.

Chúng ta có thể khắc phục điều này bằng cách sử dụng một kiểu có điều kiện (conditional type):

```ts
const youSayGoodbyeISayHello = <TInput extends "hello" | "goodbye">(
  input: TInput,
): TInput extends "hello" ? "goodbye" : "hello" => {
  if (input === "goodbye") {
    return "hello";
  } else {
    return "goodbye";
  }
};

const goodbye = youSayGoodbyeISayHello("hello");

const hello = youSayGoodbyeISayHello("goodbye");

const hello: "hello";
```

Chúng ta đã thêm một kiểu có điều kiện vào kiểu trả về của hàm phản ánh logic runtime của chúng ta. Nếu `TInput`, được suy ra từ tham số runtime, là `"hello"`, chúng ta trả về `"goodbye"`. Ngược lại, chúng ta trả về `"hello"`.

Nhưng có một vấn đề. Tôi đã cố tình tắt các lỗi trong đoạn mã trên. Hãy xem điều gì xảy ra khi chúng ta bật chúng lên:

```ts
const youSayGoodbyeISayHello = <TInput extends "hello" | "goodbye">(
  input: TInput,
): TInput extends "hello" ? "goodbye" : "hello" => {
  if (input === "goodbye") {
    return "hello";
  } else {
    return "goodbye";
  }
};
```

Ôi! TypeScript dường như không khớp kiểu có điều kiện với logic runtime. `"hello"` hoặc `"goodbye"` không thể được trả về từ hàm.

Chúng ta có thể sửa lỗi này bằng cách sử dụng `as`, và buộc nó phải là kiểu có điều kiện chính xác:

```ts
const youSayGoodbyeISayHello = <TInput extends "hello" | "goodbye">(
  input: TInput,
): TInput extends "hello" ? "goodbye" : "hello" => {
  if (input === "goodbye") {
    return "hello" as TInput extends "hello" ? "goodbye" : "hello";
  } else {
    return "goodbye" as TInput extends "hello" ? "goodbye" : "hello";
  }
};
```

Chúng ta có thể làm cho điều này đẹp hơn bằng cách trích xuất logic đó thành một generic type chung:

```ts
type YouSayGoodbyeISayHello<TInput extends "hello" | "goodbye"> =
  TInput extends "hello" ? "goodbye" : "hello";

const youSayGoodbyeISayHello = <TInput extends "hello" | "goodbye">(
  input: TInput,
): YouSayGoodbyeISayHello<TInput> => {
  if (input === "goodbye") {
    return "hello" as YouSayGoodbyeISayHello<TInput>;
  } else {
    return "goodbye" as YouSayGoodbyeISayHello<TInput>;
  }
};
```

Nhưng trong những tình huống này, thường hợp lý hơn khi sử dụng `as any`:

```ts
const youSayGoodbyeISayHello = <TInput extends "hello" | "goodbye">(
  input: TInput,
): TInput extends "hello" ? "goodbye" : "hello" => {
  if (input === "goodbye") {
    return "hello" as any;
  } else {
    return "goodbye" as any;
  }
};
```

Đúng, điều này làm cho hàm của chúng ta kém an toàn về loại hơn. Chúng ta có thể vô tình trả về `"bonsoir"` từ hàm thay thế.

Nhưng trong các tình huống này, thường tốt hơn là sử dụng `as any` và thêm một unit test cho hành vi của hàm này. Do những hạn chế của TypeScript trong việc kiểm tra những thứ này, đây thường là mức độ an toàn về kiểu gần nhất mà bạn có thể đạt được.

Có một vài trường hợp sử dụng khác như thế này, nơi bên trong các hàm generic bạn cần sử dụng `any` để giải quyết các hạn chế của TypeScript. Đối với tôi, điều này là ổn.

## Kết luận

Một câu hỏi vẫn còn đó: bạn có nên cấm `any` khỏi codebase của mình không? Tôi nghĩ, nhìn chung, câu trả lời nên là có. Bạn nên bật `quy tắc ESLint` ngăn chặn việc sử dụng nó, và bạn nên tránh nó bất cứ khi nào có thể.

Tuy nhiên, có những trường hợp `any` là cần thiết. Chúng đáng để sử dụng eslint-disable để giải quyết vấn đề. Vì vậy, hãy đánh dấu bài viết này và đính kèm nó vào các PR của bạn khi bạn cảm thấy cần phải sử dụng nó.
