---
title: "Các Mẫu Thiết Kế Cơ Bản cho Lập Trình Viên Java"
description: "Đừng phát minh lại bánh xe. Hãy học cách triển khai các mẫu thiết kế GoF cổ điển như Singleton, Factory, Builder, và Observer trong Java."
image: "/images/blog/design-patterns.png"
date: "2025-12-24"
author: "Tai Vu"
---

# Các Mẫu Thiết Kế Cơ Bản cho Lập Trình Viên Java

Các mẫu thiết kế (Design patterns) là những giải pháp đã được chứng minh cho các vấn đề thiết kế phần mềm phổ biến. Chúng cung cấp một ngôn ngữ chung cho các nhà phát triển và giúp tạo ra code linh hoạt, có thể tái sử dụng và dễ bảo trì. Trong bài viết này, chúng ta sẽ khám phá một số mẫu được sử dụng rộng rãi nhất trong Java.

## Nhóm Khởi Tạo (Creational Patterns)

### 1. Singleton
Đảm bảo một class chỉ có duy nhất một instance (thể hiện) và cung cấp một điểm truy cập toàn cục đến nó.

```java
public class DatabaseConnection {
    private static DatabaseConnection instance;

    private DatabaseConnection() {} // Private constructor

    public static synchronized DatabaseConnection getInstance() {
        if (instance == null) {
            instance = new DatabaseConnection();
        }
        return instance;
    }
}
```
*Trường hợp sử dụng: Logging, đối tượng Driver, Caching.*

### 2. Builder Pattern
Tách biệt việc xây dựng một đối tượng phức tạp khỏi biểu diễn của nó. Nó cho phép bạn tạo các đối tượng bất biến (immutable) với một fluent API.

```java
User user = new User.Builder()
    .firstName("Tai")
    .lastName("Vu")
    .age(22)
    .build();
```
*Trường hợp sử dụng: Các class có nhiều tham số khởi tạo, phần lớn là tùy chọn.*

### 3. Factory Method
Định nghĩa một interface để tạo một đối tượng, nhưng để cho các subclass quyết định class nào sẽ được khởi tạo.

## Nhóm Hành Vi (Behavioral Patterns)

### 1. Observer Pattern
Định nghĩa một sự phụ thuộc một-nhiều giữa các đối tượng để khi một đối tượng thay đổi trạng thái, tất cả các đối tượng phụ thuộc của nó sẽ được thông báo tự động.

*Trường hợp sử dụng: Event listeners, cập nhật UI, Social media feeds.*

```java
interface Observer { void update(String msg); }

class Channel {
    private List<Observer> subs = new ArrayList<>();
    public void subscribe(Observer sub) { subs.add(sub); }
    public void notify(String msg) { 
        for(Observer s : subs) s.update(msg); 
    }
}
```

### 2. Strategy Pattern
Định nghĩa một họ các thuật toán, đóng gói từng thuật toán lại và làm cho chúng có thể thay thế lẫn nhau.

```java
interface PaymentStrategy { void pay(int amount); }

class CreditCardStrategy implements PaymentStrategy { ... }
class PayPalStrategy implements PaymentStrategy { ... }

// Sử dụng
cart.pay(new PayPalStrategy());
```
*Trường hợp sử dụng: Phương thức thanh toán, thuật toán sắp xếp, chiến lược nén.*

## Nhóm Cấu Trúc (Structural Patterns)

### 1. Adapter Pattern
Cho phép các đối tượng với các interface không tương thích có thể làm việc cùng nhau. Nó hoạt động như một lớp bọc (wrapper).
*Trường hợp sử dụng: Tích hợp thư viện mới với code cũ (legacy).*

### 2. Decorator Pattern
Gắn thêm các trách nhiệm mới cho một đối tượng một cách động.
*Trường hợp sử dụng: Java I/O streams (`new BufferedReader(new FileReader(...))`).*

## Kết luận

Các mẫu thiết kế không phải là luật lệ, mà là hướng dẫn. Lạm dụng chúng có thể dẫn đến sự phức tạp không cần thiết. Tuy nhiên, việc biết *khi nào* nên áp dụng chúng là điểm khác biệt giữa một lập trình viên junior và một kiến trúc sư phần mềm senior.
