---
title: "Tận dụng Lambdas và Functional Interfaces trong Java"
description: "Một hướng dẫn toàn diện về lập trình hàm trong Java. Sử dụng Predicate, Consumer, Function, và Supplier interfaces một cách hiệu quả."
image: "/images/blog/lambdas-functional-interfaces.png"
date: "2025-12-23"
author: "Tai Vu"
---

# Tận dụng Lambdas và Functional Interfaces trong Java

Trước Java 8, Java hoàn toàn hướng đối tượng. Nếu bạn muốn truyền chức năng (functionality), bạn phải bọc nó trong một class hoặc một anonymous inner class. Java 8 đã thay đổi cuộc chơi bằng cách giới thiệu biểu thức Lambda và Functional Interfaces, mang các khái niệm lập trình hàm vào JDK.

## Functional Interface là gì?

Một Functional Interface là một interface chứa chính xác **một phương thức trừu tượng**. Nó có thể có nhiều phương thức mặc định (default) hoặc tĩnh (static), nhưng chỉ có thể có một phương thức trừu tượng.

Annotation `@FunctionalInterface` đảm bảo quy tắc này được thực thi bởi trình biên dịch.

```java
@FunctionalInterface
public interface Calculator {
    int calculate(int a, int b);
}
```

## Biểu thức Lambda

Lambdas cung cấp một cách rõ ràng và ngắn gọn để đại diện cho một interface chỉ có một phương thức bằng một biểu thức.

**Trước Java 8 (Anonymous Class):**
```java
Calculator add = new Calculator() {
    @Override
    public int calculate(int a, int b) {
        return a + b;
    }
};
```

**Java 8 (Lambda):**
```java
Calculator add = (a, b) -> a + b;
```

## Các Functional Interfaces tích hợp sẵn

Java cung cấp gói `java.util.function` với các interface sẵn dùng. Bạn hiếm khi cần phải tạo cái riêng của mình.

### 1. Predicate\<T\>
Nhận một đối số và trả về một `boolean`.
*   Phương thức trừu tượng: `boolean test(T t)`
*   Trường hợp sử dụng: Lọc (Filtering).

```java
Predicate<String> isLong = s -> s.length() > 10;
boolean result = isLong.test("Hello World"); // true
```

### 2. Consumer\<T\>
Nhận một đối số và không trả về gì (`void`).
*   Phương thức trừu tượng: `void accept(T t)`
*   Trường hợp sử dụng: In ấn, lưu vào DB.

```java
Consumer<String> printer = s -> System.out.println(s);
printer.accept("Java is fun");
```

### 3. Function\<T, R\>
Nhận một đối số kiểu T và trả về kết quả kiểu R.
*   Phương thức trừu tượng: `R apply(T t)`
*   Trường hợp sử dụng: Biến đổi / Ánh xạ.

```java
Function<String, Integer> lengthMapper = String::length;
int len = lengthMapper.apply("Code"); // 4
```

### 4. Supplier\<T\>
Không nhận đối số và trả về một kết quả.
*   Phương thức trừu tượng: `T get()`
*   Trường hợp sử dụng: Tạo lazy, factories.

```java
Supplier<Double> randomizer = Math::random;
```

## Method References (Tham chiếu phương thức)

Nếu lambda của bạn chỉ gọi một phương thức hiện có, bạn có thể sử dụng tham chiếu phương thức `::` để code sạch hơn.
*   `s -> System.out.println(s)` trở thành `System.out::println`
*   `s -> s.toUpperCase()` trở thành `String::toUpperCase`

## Kết luận

Lambdas và Functional interfaces giảm mã soạn sẵn (boilerplate code) và làm cho ý định của bạn rõ ràng hơn. Chúng là xương sống của Streams API và lập trình bất đồng bộ `CompletableFuture`. Nắm vững chúng là chìa khóa để viết code Java hiện đại và sạch sẽ.
