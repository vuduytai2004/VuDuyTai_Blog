---
title: "Virtual Threads: Tương lai của Đồng thời trong Java (Project Loom)"
description: "Project Loom đã đến! Tìm hiểu cách Virtual Threads trong Java 21 thay đổi bối cảnh đồng thời, khiến lập trình phản ứng trở nên lỗi thời đối với nhiều trường hợp sử dụng."
image: "/images/blog/virtual-threads-java-21.png"
date: "2025-12-24"
author: "Tai Vu"
---

# Virtual Threads: Tương lai của Đồng thời trong Java (Project Loom)

Trong nhiều thập kỷ, đơn vị đồng thời trong Java là `Thread`. Các "luồng nền tảng" (platform threads) này là các lớp bao quanh các luồng hệ điều hành (OS threads). Mặc dù mạnh mẽ, nhưng chúng tốn kém để tạo và quản lý. Một máy chủ điển hình có thể xử lý vài nghìn luồng nền tảng trước khi hết bộ nhớ. Hạn chế này dẫn đến sự gia tăng của các framework lập trình phản ứng, bất đồng bộ (như WebFlux) để xử lý đồng thời cao, thường phải trả giá bằng độ phức tạp của code.

**Java 21 và Virtual Threads tham chiến.**

## Virtual Threads là gì?

Virtual threads (luồng ảo) là các luồng chế độ người dùng được quản lý bởi JVM, không phải hệ điều hành. Chúng:
*   **Nhẹ**: Bạn có thể tạo *hàng triệu* luồng ảo trong một JVM duy nhất.
*   **Rẻ**: Thời gian tạo là không đáng kể.
*   **Chặn là Miễn phí**: Khi một luồng ảo chặn (ví dụ: chờ I/O), luồng hệ điều hành bên dưới được giải phóng để thực hiện công việc khác.

## Vấn đề với Platform Threads (Thread-per-Request)

Trong mô hình "Thread-per-Request" cổ điển, máy chủ web chỉ định một luồng để xử lý toàn bộ yêu cầu. Nếu yêu cầu liên quan đến việc gọi cơ sở dữ liệu mất 100ms, luồng hệ điều hành đắt tiền đó sẽ ngồi không trong 100ms. Điều này hạn chế khả năng mở rộng.

## Giải pháp: Virtual Threads

Với virtual threads, chúng ta có thể gắn bó với kiểu "Thread-per-Request" đơn giản. Khi code của bạn thực hiện lệnh gọi DB đó, JVM sẽ ngắt kết nối luồng ảo và luồng hệ điều hành sẽ đi phục vụ luồng ảo khác. Khi dữ liệu đến, JVM sẽ lên lịch lại cho luồng ảo.

```java
// Tạo một Virtual Thread
Thread.startVirtualThread(() -> {
    System.out.println("Đang chạy trong một luồng ảo!");
});

// Sử dụng ExecutorService với Virtual Threads
try (var executor = Executors.newVirtualThreadPerTaskExecutor()) {
    IntStream.range(0, 100_000).forEach(i -> {
        executor.submit(() -> {
            Thread.sleep(Duration.ofSeconds(1)); // Điều này không chặn luồng hệ điều hành!
            return i;
        });
    });
}
```

Trong ví dụ trên, chúng ta tạo ra 100.000 luồng. Nếu đây là các luồng nền tảng, ứng dụng có thể sẽ bị sập. Với luồng ảo, nó chạy trơn tru trên một máy tính xách tay khiêm tốn.

## Lợi ích so với Lập trình Phản ứng (Reactive Programming)

Lập trình phản ứng (RxJava, Reactor) giải quyết vấn đề khả năng mở rộng nhưng gây ra "Callback Hell" và khiến việc gỡ lỗi/stack-traces trở thành một cơn ác mộng. Virtual threads mang lại cho bạn **khả năng mở rộng của code bất đồng bộ** với **sự đơn giản của code đồng bộ**.

*   Luồng điều khiển tiêu chuẩn (vòng lặp, try-catch) hoạt động như mong đợi.
*   Stack traces có ý nghĩa.
*   Trình gỡ lỗi làm việc bình thường.

## Xác định khi nào nên sử dụng chúng

Virtual threads lý tưởng cho các **tác vụ I/O-bound** (máy chủ web, gọi cơ sở dữ liệu, microservices). Chúng *không* phải là sự thay thế cho các luồng nền tảng cho các **tác vụ CPU-bound** (xử lý video, tính toán nặng), vì việc chuyển đổi luồng sẽ không giúp ích gì nếu lõi CPU đã bận 100%.

## Kết luận

Virtual threads được coi là thay đổi lớn nhất đối với Java kể từ Lambdas trong Java 8. Chúng cho phép chúng ta viết code đơn giản, chặn mà có khả năng mở rộng điên cuồng. Đã đến lúc gỡ bỏ những đường ống phản ứng phức tạp đó và nắm lấy sự đơn giản của chặn I/O một lần nữa!
