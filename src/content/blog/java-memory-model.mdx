---
title: "Understanding the Java Memory Model (JMM)"
description: "The Stack, the Heap, and the happens-before relationship. A technical guide to how Java manages memory and thread visibility."
image: "/images/blog/java-memory-model.png"
date: "2025-12-24"
author: "Tai Vu"
---


# Understanding the Java Memory Model (JMM)

The Java Memory Model (JMM) is a specification that guarantees how the Java Virtual Machine (JVM) interacts with the computer's memory (RAM). It is crucial for understanding how variables are stored and how threads interact with shared data.

## Memory Structure: Stack vs. Heap

### The Stack
*   Each Thread has its own Stack.
*   Stores **primitive variables** (int, boolean, etc.) and **references** to objects.
*   Variables here are only visible to the owner thread.
*   Fast access, LIFO (Last In First Out) structure.

### The Heap
*   Shared by all threads.
*   Stores **actual Objects** (String, Integer, Custom Classes like `User`).
*   Garbage Collection happens here.

**Example**:
```java
void method() {
    int x = 10; // Stored on Stack
    User user = new User("Tai"); // reference 'user' on Stack, Object 'User' on Heap
}
```

## Concurrency Issues

When multiple threads access the same object on the Heap, we encounter two main problems:

1.  **Race Conditions**: When threads read/write shared data simultaneously, and the final result depends on the timing of execution.
2.  **Memory Visibility**: Local CPU built-in caches can keep copies of variables. Thread A might update a variable, but Thread B might still see the old value from its cache.

## The Volatile Keyword

The `volatile` keyword ensures **visibility**. It guarantees that any read or write to a variable is done directly to main memory, skipping CPU caches.

```java
public class SharedData {
    private volatile boolean running = true;

    public void stop() {
        running = false; // Immediately visible to other threads
    }
}
```

## Synchronized and Locks

To solve Race Conditions (atomicity issues), we need synchronization.

```java
public synchronized void increment() {
    count++;
}
```
This ensures only one thread can execute this method at a time on a given object instance. It provides both atomicity and visibility.

## The "Happens-Before" Relationship

This is the core guarantee of the JMM. If Action A *happens-before* Action B, then the results of A are visible to B.
*   Releasing a lock *happens-before* acquiring the same lock.
*   Writing to a `volatile` variable *happens-before* reading it.
*   A thread start *happens-before* any action in the started thread.

## Conclusion

The JMM abstracts away the underlying hardware details, providing a consistent environment for writing multithreaded applications. However, bugs related to memory visibility and race conditions are notoriously hard to reproduce, making a solid understanding of these concepts mandatory for senior Java engineers.

