---
title: "Hiểu về Mô Hình Bộ Nhớ Java (JMM)"
description: "Stack, Heap, và mối quan hệ happens-before. Hướng dẫn kỹ thuật về cách Java quản lý bộ nhớ và khả năng hiển thị của luồng."
image: "/images/blog/java-memory-model.png"
date: "2025-12-24"
author: "Tai Vu"
---

# Hiểu về Mô Hình Bộ Nhớ Java (JMM)

Mô hình Bộ nhớ Java (Java Memory Model - JMM) là một đặc tả đảm bảo cách Máy ảo Java (JVM) tương tác với bộ nhớ máy tính (RAM). Nó rất quan trọng để hiểu cách các biến được lưu trữ và cách các luồng (threads) tương tác với dữ liệu chia sẻ.

## Cấu trúc Bộ nhớ: Stack vs. Heap

### The Stack (Ngăn xếp)
*   Mỗi Thread có Stack riêng của nó.
*   Lưu trữ các **biến nguyên thủy** (int, boolean, v.v.) và **tham chiếu** đến các đối tượng.
*   Các biến ở đây chỉ hiển thị với luồng sở hữu chúng.
*   Truy cập nhanh, cấu trúc LIFO (Vào sau ra trước).

### The Heap (Đống)
*   Được chia sẻ bởi tất cả các luồng.
*   Lưu trữ **các Đối tượng thực sự** (String, Integer, Custom Classes như `User`).
*   Garbage Collection (Thu gom rác) diễn ra ở đây.

**Ví dụ**:
```java
void method() {
    int x = 10; // Lưu trên Stack
    User user = new User("Tai"); // tham chiếu 'user' trên Stack, Đối tượng 'User' trên Heap
}
```

## Các vấn đề về Đồng thời (Concurrency Issues)

Khi nhiều luồng truy cập cùng một đối tượng trên Heap, chúng ta gặp phải hai vấn đề chính:

1.  **Race Conditions (Điều kiện đua)**: Khi các luồng đọc/ghi dữ liệu chia sẻ đồng thời, và kết quả cuối cùng phụ thuộc vào thời điểm thực thi.
2.  **Memory Visibility (Khả năng hiển thị bộ nhớ)**: Các bộ nhớ cache tích hợp trong CPU cục bộ có thể giữ các bản sao của biến. Luồng A có thể cập nhật một biến, nhưng Luồng B vẫn có thể thấy giá trị cũ từ cache của nó.

## Từ khóa Volatile

Từ khóa `volatile` đảm bảo tính **hiển thị (visibility)**. Nó đảm bảo rằng mọi thao tác đọc hoặc ghi vào một biến đều được thực hiện trực tiếp vào bộ nhớ chính, bỏ qua cache CPU.

```java
public class SharedData {
    private volatile boolean running = true;

    public void stop() {
        running = false; // Ngay lập tức hiển thị với các luồng khác
    }
}
```

## Synchronized và Locks

Để giải quyết Race Conditions (vấn đề nguyên tử), chúng ta cần đồng bộ hóa (synchronization).

```java
public synchronized void increment() {
    count++;
}
```
Điều này đảm bảo chỉ một luồng có thể thực thi phương thức này tại một thời điểm trên một instance đối tượng nhất định. Nó cung cấp cả tính nguyên tử và tính hiển thị.

## Mối quan hệ "Happens-Before"

Đây là đảm bảo cốt lõi của JMM. Nếu Hành động A *happens-before* (xảy ra trước) Hành động B, thì kết quả của A sẽ hiển thị với B.
*   Việc giải phóng một lock *happens-before* việc thu thập cùng lock đó.
*   Ghi vào một biến `volatile` *happens-before* việc đọc nó.
*   Khởi chạy một luồng *happens-before* bất kỳ hành động nào trong luồng đã khởi chạy.

## Kết luận

JMM trừu tượng hóa các chi tiết phần cứng bên dưới, cung cấp một môi trường nhất quán để viết các ứng dụng đa luồng. Tuy nhiên, các lỗi liên quan đến hiển thị bộ nhớ và race conditions thường rất khó tái tạo, khiến việc hiểu vững các khái niệm này là bắt buộc đối với các kỹ sư Java senior.
