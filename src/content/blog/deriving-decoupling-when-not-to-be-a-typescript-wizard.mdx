---
title: "Deriving vs Decoupling: Khi nào KHÔNG nên làm một 'Phù thủy Typescript'"
description: "Trong đoạn giới thiệu sách này, chúng ta thảo luận về việc deriving (dẫn xuất) so với decoupling (tách rời) các loại của bạn: khi nào việc xây dựng mối quan hệ giữa các loại hoặc tách biệt chúng là hợp lý"
image: "/images/blog/derive-decouple.webp"
date: "2024-05-30"
author: "devbertskie"
---

Một trong những lời khuyên phổ biến nhất để viết code dễ bảo trì là "Giữ cho code DRY" (Don't Repeat Yourself - Đừng lặp lại chính mình).

Một cách để làm điều này trong JavaScript là lấy code lặp lại và nắm bắt nó trong các hàm hoặc biến. Các biến và hàm này có thể được sử dụng lại, kết hợp và kết hợp theo nhiều cách khác nhau để tạo chức năng mới.

Trong TypeScript, chúng ta có thể áp dụng nguyên tắc tương tự này cho các kiểu (types).

## Derived Type (Kiểu dẫn xuất) là gì?

Một derived type là một kiểu dựa vào, hoặc kế thừa từ, cấu trúc của một kiểu khác. Chúng ta có thể tạo các derived type bằng cách sử dụng một số công cụ mà chúng ta đã sử dụng cho đến nay.

Chúng ta có thể sử dụng `interface extends` để làm cho một interface kế thừa từ một interface khác:

```ts
interface Album {
  title: string;
  artist: string;
  releaseYear: number;
}

interface AlbumDetails extends Album {
  genre: string;
}
```

`AlbumDetails` kế thừa tất cả các thuộc tính của `Album`. Điều này có nghĩa là bất kỳ thay đổi nào đối với `Album` sẽ ảnh hưởng đến `AlbumDetails`. `AlbumDetails` được dẫn xuất từ `Album`.

Một ví dụ khác là union type (kiểu hợp).

```ts
type Triangle = {
  type: "triangle";
  sideLength: number;
};

type Rectangle = {
  type: "rectangle";
  width: number;
  height: number;
};

type Shape = Triangle | Rectangle;
```

Một derived type đại diện cho một mối quan hệ. Mối quan hệ đó là một chiều. `Shape` không thể quay lại và sửa đổi `Triangle` hoặc `Rectangle`. Nhưng bất kỳ thay đổi nào đối với `Triangle` và `Rectangle` sẽ lan truyền qua `Shape`.

## Deriving vs Decoupling (Dẫn xuất vs Tách rời)

Khi bạn dẫn xuất một kiểu từ một nguồn, bạn đang ghép (couple) kiểu dẫn xuất vào nguồn đó. Nếu bạn dẫn xuất một kiểu từ một kiểu dẫn xuất khác, điều này có thể tạo ra các chuỗi ghép nối dài trong ứng dụng của bạn mà có thể khó quản lý.

### Khi nào Decoupling (Tách rời) là hợp lý

Hãy tưởng tượng chúng ta có một kiểu `User` trong tệp `db.ts`:

```ts
export type User = {
  id: string;
  name: string;
  imageUrl: string;
  email: string;
  bio: string;
};
```

Giả sử cho ví dụ này rằng chúng ta đang sử dụng một framework dựa trên component như React, Vue hoặc Svelte. Chúng ta có một component `AvatarImage` hiển thị hình ảnh của người dùng. Chúng ta có thể truyền vào trực tiếp kiểu `User`:

```ts
import { User } from "./db";
export const AvatarImage = (props: { user: User }) => {
  return <img src={props.user.imageUrl} alt={props.user.name} />;
};
```

Nhưng hóa ra, chúng ta chỉ sử dụng các thuộc tính `imageUrl` và `name` từ kiểu `User`. Ý tưởng hay là làm cho các hàm và component của bạn chỉ yêu cầu dữ liệu chúng cần để chạy. Điều này giúp ngăn bạn truyền dữ liệu không cần thiết.

Hãy thử dẫn xuất (deriving). Chúng ta sẽ tạo một kiểu mới gọi là `AvatarImageProps` chỉ bao gồm các thuộc tính chúng ta cần:

```ts
import { User } from "./db";
type AvatarImageProps = Pick<User, "imageUrl" | "name">;
```

Nhưng hãy suy nghĩ một chút. Bây giờ chúng ta đã ghép kiểu `AvatarImageProps` vào kiểu `User`. `AvatarImageProps` bây giờ không chỉ phụ thuộc vào hình dạng của `User`, mà còn sự tồn tại của nó trong tệp `db.ts`. Điều này có nghĩa là nếu chúng ta di chuyển vị trí của kiểu `User`, hoặc chia nó thành các interface riêng biệt, chúng ta sẽ cần suy nghĩ về `AvatarImageProps`.

Hãy thử cách ngược lại. Thay vì dẫn xuất `AvatarImageProps` từ `User`, chúng ta sẽ tách rời (decouple) chúng. Chúng ta sẽ tạo một kiểu mới chỉ có các thuộc tính chúng ta cần:

```ts
type AvatarImageProps = {
  imageUrl: string;
  name: string;
};
```

Bây giờ, `AvatarImageProps` đã được tách rời khỏi `User`. Chúng ta có thể di chuyển `User` xung quanh, chia nó thành các interface riêng biệt, hoặc thậm chí xóa nó, và `AvatarImageProps` sẽ không bị ảnh hưởng.

Trong trường hợp cụ thể này, decoupling cảm thấy là lựa chọn đúng đắn. Điều này là do `User` và `AvatarImage` là các mối quan tâm riêng biệt. `User` là một kiểu dữ liệu, trong khi `AvatarImage` là một UI component. Chúng có các trách nhiệm khác nhau và lý do khác nhau để thay đổi. Bằng cách tách rời chúng, AvatarImage trở nên di động hơn và dễ bảo trì hơn.

Điều có thể làm cho việc tách rời trở thành một quyết định khó khăn là việc dẫn xuất có thể khiến bạn cảm thấy 'thông minh'. `Pick` cám dỗ chúng ta bởi vì nó sử dụng một tính năng nâng cao hơn của TypeScript, điều này khiến chúng ta cảm thấy tốt khi áp dụng kiến thức chúng ta đã đạt được. Nhưng thường thì, thông minh hơn là làm điều đơn giản, và giữ cho các kiểu của bạn được tách rời.

## Khi nào Deriving (Dẫn xuất) là hợp lý

Việc dẫn xuất có ý nghĩa nhất khi code bạn đang ghép nối chia sẻ một mối quan tâm chung. Các ví dụ trong chương này là những ví dụ điển hình về điều này. Đối tượng `as const` của chúng ta chẳng hạn:

```ts
const albumTypes = {
  CD: "cd",
  VINYL: "vinyl",
  DIGITAL: "digital",
} as const;

type AlbumType = (typeof albumTypes)[keyof typeof albumTypes];
```

Ở đây, `AlbumType` được dẫn xuất từ `albumTypes`. Nếu chúng ta tách rời nó, chúng ta sẽ phải duy trì hai nguồn sự thật liên quan chặt chẽ:

```ts
type AlbumType = "cd" | "vinyl" | "digital";
```

Bởi vì cả `AlbumType` và `albumTypes` đều liên quan chặt chẽ, việc dẫn xuất AlbumType từ `albumTypes` là hợp lý.

Một ví dụ khác là khi một kiểu liên quan trực tiếp đến một kiểu khác. Ví dụ, kiểu `User` của chúng ta có thể có kiểu `UserWithoutId` được dẫn xuất từ nó:

```ts
type User = {
  id: string;
  name: string;
  imageUrl: string;
  email: string;
};

type UserWithoutId = Omit<User, "id">;

const updateUser = (id: string, user: UserWithoutId) => {
  // ...
};
```

Một lần nữa, những mối quan tâm này liên quan chặt chẽ với nhau. Việc tách rời chúng sẽ làm cho code của chúng ta khó bảo trì hơn và đưa thêm nhiều việc bận rộn vào codebase của chúng ta.

Quyết định dẫn xuất hay tách rời đều là về việc giảm khối lượng công việc trong tương lai của bạn.

Liệu hai kiểu có liên quan đến mức các cập nhật cho một kiểu sẽ cần lan truyền sang kiểu kia không? Dẫn xuất.

Liệu chúng có không liên quan đến mức việc ghép nối chúng có thể dẫn đến nhiều công việc hơn sau này không? Tách rời.
